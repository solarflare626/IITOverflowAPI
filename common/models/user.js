'use strict';

const CLIENT_ID ='976545483152-vsg906t0vnk04b5gra3861c98jqi7hcq.apps.googleusercontent.com';
const {OAuth2Client} = require('google-auth-library');
const client = new OAuth2Client(CLIENT_ID);

async function verify(myIdToken) {
  const ticket = await client.verifyIdToken({
      idToken: myIdToken,
      audience: ['976545483152-sl04nepnigt5mi15g5ahkqrholfiprjk.apps.googleusercontent.com',
      '976545483152-sqe7ionbfs9t8jnq8a6mrnvclsdsg222.apps.googleusercontent.com',
      '976545483152-3u1fctn90tf0qvjevud1hkfu3jdneog0.apps.googleusercontent.com',
      '976545483152-fhtdk4qhsb5akkuakilskicqkpiap77i.apps.googleusercontent.com',
      '976545483152-vsg906t0vnk04b5gra3861c98jqi7hcq.apps.googleusercontent.com'],  // Specify the CLIENT_ID of the app that accesses the backend
      // Or, if multiple clients access the backend:
      //[CLIENT_ID_1, CLIENT_ID_2, CLIENT_ID_3]

  });
  const payload = ticket.getPayload();
  const userid = payload['sub'];
  
  return payload;
  //return callback(userid);
  // If request specified a G Suite domain:
  //const domain = payload['hd'];
}

module.exports = function(User) {

 	
	User.beforeCreate = function (next, model) {
    model.createdAt = Date.now();
    next();
  };

  User.beforeUpdate = function (next, model) {
    model.updatedAt = Date.now();
    next();
  };

User.addToLogin = function (credentials, include, callback) {



		
		console.log("IDTOKEN: ", credentials.idToken);

		verify(credentials.idToken).then(data=>{

			console.log("Data", data);
  
			var account = {"email": data.email, "password": "secret","displayname": data.name,picture : data.picture}
				User.findOrCreate({where: {email: account.email}},account, function (findErr, userData) {
						if (findErr)
							return callback(findErr);



						console.log("exists");
						return User.login(account, include, function (loginErr, loginToken) {
							if (loginErr)
								return callback(loginErr);
							/* If we got to this point, the login call was successfull and we
							 * have now access to the token generated by the login function.
							 *
							 * This means that now we can add extra logic and manipulate the
							 * token before returning it. Unfortunately, the login function
							 * does not return the user data, so if we need it we need to hit
							 * the datasource again to retrieve it.
							 */

							// If needed, here we can use loginToken.userId to retrieve
							// the user from the datasource
							return User.findById(loginToken.userId, function (findErr, userData) {
								if (findErr)
									return callback(findErr);

								// Here you can do something with the user info, or the token, or both

								// Return the access token
								return callback(null, loginToken.toObject());
							});
						});

						// Here you can do something with the user info, or the token, or both

						// Return the access token
						
						//return callback(null, loginToken.toObject());
				});
		
		// Invoke the default login function


		}).catch(error=>{

			return callback(error);
		});

 		
		
		
	};

	/** Register a path for the new login function
	 */
	User.remoteMethod('addToLogin', {
		'http': {
			'path': '/OAuthLogin',
			'verb': 'post'
		},
		'accepts': [
			{
				'arg': 'credentials',
				'type': 'object',
				'description': 'Login credentials',
				'required': true,
				'http': {
					'source': 'body'
				}
			},
			{
				'arg': 'include',
				'type': 'string',
				'description': 'Related objects to include in the response. See the description of return value for more details.',
				'http': {
					'source': 'query'
				}
			}
		],
		'returns': [
			{
				'arg': 'token',
				'type': 'object',
				'root': true
			}
		]
});
};
